
# Design Patterns 詳細學習報告

## 1. 前言與核心設計原則

1.  **封裝會變動的部分 (Encapsulate what varies)**：將系統中不穩定或經常改變的部分獨立出來，避免影響其他穩定的部分。
2.  **泛化共同特徵 (Generalize common features)**：提取不同類別間的共同行為，通常透過抽象類別或介面來實現。
3.  **針對介面撰寫程式，而非針對實作 (Program to an interface, not an implementation)**：客戶端應依賴於抽象介面，而非具體的實作類別，以增加系統的彈性。

---

## 2. 行為型模式 (Behavioral Patterns)

### 2.1 Observer Pattern (觀察者模式)
*   **應用場景**：試算表應用程式（Spreadsheet Application）。一個應用程式數據物件（Application Data）可能同時被試算表（Spreadsheet）、長條圖（BarChart）和圓餅圖（PieChart）呈現。
*   **問題**：若有多種呈現方式依賴於同一份數據，當數據變更時，需要通知所有呈現物件。如果直接在數據物件中呼叫各個圖表的更新方法，未來新增圖表類型時就必須修改程式碼。
*   **解決方案**：定義一個 `Subject`（數據）和多個 `Observer`（圖表）。Subject 提供 `attach` 和 `detach` 方法來管理觀察者。當數據改變時，Subject 呼叫 `notify` 統一通知所有註冊的 Observer。
*   **意圖**：定義物件間的一對多依賴關係，當一個物件改變狀態時，其所有依賴者都會收到通知並自動更新。

### 2.2 Iterator Pattern (迭代器模式)
*   **應用場景**：合併兩家餐廳的菜單（Pancake House 和 Diner）。一家使用 `ArrayList` 儲存菜單，另一家使用 `Array`。女服務生需要同時列印這兩份菜單。
*   **問題**：若要存取不同內部實作（ArrayList vs Array）的聚合物件元素，客戶端程式碼（女服務生）必須針對不同實作寫兩套迴圈邏輯。若新增第三種儲存方式，程式碼將難以維護。
*   **解決方案**：建立 `Iterator` 介面（包含 `hasNext()`, `next()` 等方法）。讓各個菜單類別實作 `createIterator()` 方法，回傳各自的迭代器。客戶端只需透過 Iterator 介面即可走訪元素，無需知道底層結構。
*   **意圖**：提供一種方法順序存取一個聚合物件的元素，而不暴露其底層表示法。

### 2.3 Command Pattern (命令模式)
*   **應用場景**：
    1.  **萬用遙控器**：遙控器需要控制立體音響、電燈等多種家電。
    2.  **文件編輯器**：選單中的剪下、複製、貼上功能。
*   **問題**：
    *   遙控器：若直接在遙控器程式碼中寫死對特定家電（如 `Stereo`, `Light`）的呼叫，當更換家電或新增功能時，遙控器程式碼需頻繁修改。
    *   編輯器：選單項目（Invoker）與實際執行的操作（Receiver，如 Document）若緊密耦合，難以將操作重用於其他 UI 元件。
*   **解決方案**：將請求封裝成一個物件（Command）。定義 `Command` 介面（包含 `execute()`）。具體的命令物件（如 `LightOnCommand`）持有接收者（`Light`）的參考，並在 `execute()` 中呼叫接收者的方法。遙控器只需持有 Command 物件即可。
*   **意圖**：將請求封裝為物件，使你可用不同的請求對客戶進行參數化，並支援排隊、記錄請求或復原操作。

### 2.4 Strategy Pattern (策略模式)
*   **應用場景**：文件排版系統（Text Composition）。需要將元件排列成行，且有不同的斷行演算法（如 Simple, TeX, Array）。
*   **問題**：如果將斷行邏輯直接寫在 `Composition` 類別中，要新增或切換演算法時非常困難，且類別會變得龐大。
*   **解決方案**：定義 `Compositor`（策略）介面。將不同的斷行演算法封裝成具體的策略類別（`SimpleCompositor`, `TexCompositor`）。`Composition` 物件持有一個 `Compositor` 的參考，並將排版工作委派給它。
*   **意圖**：定義一族演算法，將它們分別封裝起來，並讓它們可以互相替換。策略模式讓演算法的變動獨立於使用它的客戶端。

### 2.5 Template Method Pattern (樣板方法模式)
*   **應用場景**：準備咖啡因飲料（茶和咖啡）。兩者製作步驟相似：煮水 -> 沖泡/浸泡 -> 倒入杯中 -> 加入調味。
*   **問題**：兩個類別中有大量重複的程式碼（如煮水、倒杯子），若演算法改變，需同時修改多處。
*   **解決方案**：在父類別 `CaffeineBeverage` 中定義一個 `prepareRecipe()` 方法（樣板方法），規範演算法的骨架。將共同步驟（煮水）在父類別實作，將不同步驟（`brew()`, `addCondiments()`）宣告為抽象方法，留給子類別（Tea, Coffee）去實作。
*   **意圖**：在一個操作中定義演算法的骨架，將某些步驟延遲到子類別中實現。樣板方法讓子類別在不改變演算法結構的情況下，重新定義演算法的某些步驟。

### 2.6 State Pattern (狀態模式)
*   **應用場景**：糖果機（Gumball Machine）。機器有多種狀態（無硬幣、有硬幣、售出、售罄），不同動作（投入硬幣、轉動曲柄）在不同狀態下有不同行為。
*   **問題**：若使用大量的 `if-else` 或 `switch` 判斷當前狀態來決定行為，程式碼將難以維護。新增狀態時需修改所有方法的條件判斷。
*   **解決方案**：定義 `State` 介面，將每個狀態的行為封裝在具體的狀態類別中（如 `HasQuarterState`, `SoldState`）。糖果機持有一個當前狀態物件，並將動作委派給該狀態物件處理。
*   **意圖**：允許一個物件在其內部狀態改變時改變其行為。該物件看起來像是改變了它的類別。

### 2.7 Visitor Pattern (訪問者模式)
*   **應用場景**：編譯器與抽象語法樹（AST）。AST 有多種節點（如 `AssignmentNode`, `VariableRefNode`），編譯器需對這些節點執行多種操作（型別檢查、程式碼生成、列印內容）。
*   **問題**：若將操作直接寫在節點類別中，當需要新增操作時（例如新增一個優化步驟），必須修改所有節點類別，違反封閉原則。
*   **解決方案**：定義 `Visitor` 介面，包含存取各類節點的方法（如 `visitAssignmentNode`）。節點類別增加一個 `accept(Visitor)` 方法。將操作邏輯移至具體的 Visitor 類別（如 `TypeChecker`）。透過雙重分派（Double Dispatch），讓 Visitor 能夠對不同節點執行操作。
*   **意圖**：表示一個作用於某物件結構中各元素的操作。Visitor 讓你在不改變元素類別的前提下，定義作用於這些元素的新操作。

---

## 3. 結構型模式 (Structural Patterns)

### 3.1 Façade Pattern (外觀模式)
*   **應用場景**：
    1.  **編譯器環境**：客戶端需要使用 Scanner, Parser, ProgramNode 等多個複雜類別來編譯程式碼。
    2.  **家庭劇院**：看電影需要操作爆米花機、燈光、螢幕、投影機、擴大機、DVD 播放器等多個設備。
*   **問題**：客戶端與子系統中的多個元件緊密耦合。若子系統改變，客戶端需大幅修改；且客戶端程式碼充滿了對子系統細節的呼叫。
*   **解決方案**：建立一個高層介面（如 `Compiler` 類別或 `WatchAMovie` 類別），提供一個簡單的方法（如 `compile()` 或 `watchAMovie()`）來統籌呼叫子系統的各個元件。客戶端僅需與這個 Façade 物件互動。
*   **意圖**：為子系統中的一組介面提供一個統一的介面。Façade 定義了一個高層介面，讓子系統更易於使用。

### 3.2 Adapter Pattern (轉接器模式)
*   **應用場景**：現有系統依賴一個舊廠商的類別庫，現在想換成新廠商的類別庫，但新介面與舊介面不相容。
*   **問題**：若直接修改現有系統去呼叫新介面，變動太大且違反依賴關係。
*   **解決方案**：建立一個 `Adapter` 類別，實作客戶端期望的介面（Target），並在其內部持有新廠商物件（Adaptee）的參考（Object Adapter）或繼承新廠商類別（Class Adapter）。Adapter 將客戶端的請求轉換為對 Adaptee 的呼叫。
*   **意圖**：將一個類別的介面轉換成客戶端期望的另一個介面。Adapter 讓原本因介面不相容而無法合作的類別可以一起工作。
*   **比較**：**Class Adapter** (使用繼承) vs **Object Adapter** (使用組合物件)。

### 3.3 Composite Pattern (組合物件模式)
*   **應用場景**：電路圖繪製系統（Schematic Capture）。圖形包含基本元件（線、矩形、文字）和群組元件（Group），群組內可包含其他基本元件或群組。
*   **問題**：若客戶端必須區分「單一物件」與「群組物件」，程式碼會變得很複雜且難以維護。
*   **解決方案**：讓基本元件和群組元件都實作相同的 `Component` 介面（包含 `draw()`）。群組元件的 `draw()` 會遞迴呼叫其子元件的 `draw()`。客戶端可以一致地對待個別物件與組合物件。
*   **意圖**：將物件組合成樹狀結構以表示「部分-整體」的階層關係。Composite 讓客戶端能一致地對待個別物件和組合物件。

### 3.4 Decorator Pattern (裝飾者模式)
*   **應用場景**：Starbuzz 咖啡訂單系統。咖啡（HouseBlend, DarkRoast）可以加入多種配料（牛奶、摩卡、奶泡），計算價格。
*   **問題**：若利用繼承來處理所有配料組合（如 `HouseBlendWithMochaAndWhip`），會導致「類別爆炸」。若在父類別寫死配料變數，則缺乏彈性（靜態繼承）。
*   **解決方案**：定義裝飾者類別（`CondimentDecorator`）繼承自 `Beverage`，並持有一個 `Beverage` 物件。透過層層包裝（Wrap）的方式，動態地加上責任（如計算價格時加上配料價格）。
*   **意圖**：動態地將責任附加到物件上。Decorator 提供了繼承之外的另一個彈性選擇來擴充功能。
*   **比較**：**Composite** 專注於樹狀結構與統一處理；**Decorator** 專注於動態添加功能，且一次只包裝一個物件。

### 3.5 Flyweight Pattern (享元模式)
*   **應用場景**：文件編輯器。文件中可能有成千上萬個字元物件。
*   **問題**：若每個字元都建立一個獨立物件（包含字型、位置等），記憶體消耗將過於巨大。
*   **解決方案**：區分**內部狀態 (Intrinsic State)**（如字元代碼、字型，可共享）與**外部狀態 (Extrinsic State)**（如位置，不可共享）。建立共享的 `Flyweight` 物件池，外部狀態則由客戶端在呼叫時傳入。
*   **意圖**：運用共享技術有效地支援大量細粒度的物件。
*   **限制**：Flyweight 物件必須是不可變的 (Immutable)。

---

## 4. 創建型模式 (Creational Patterns)

### 4.1 Builder Pattern (建造者模式)
*   **應用場景**：
    1.  **RTF 轉換器**：將 RTF 文件轉換為 TeX、Text Widget 等不同格式。
    2.  **假期規劃器**：規劃一般假期或背包客假期，包含訂飯店、買票等步驟。
*   **問題**：若將讀取邏輯與建立特定格式的邏輯綁在一起，難以支援新格式。
*   **解決方案**：定義 `Builder` 介面，規範建立各個部件的方法。具體的 Builder（如 `TeXConverter`, `NormalVacationBuilder`）負責實作。`Director`（如 `RTFReader`, `VacationPlanner`）負責指揮建造過程，但不涉入具體細節。
*   **意圖**：將一個複雜物件的建構與它的表示分離，使得同樣的建構過程可以建立不同的表示。

### 4.2 Singleton Pattern (單例模式)
*   **應用場景**：巧克力鍋爐（Chocolate Boiler）。系統中只允許有一個鍋爐實體，以避免狀態不一致（如同時煮沸與填充）。
*   **問題**：全域變數無法保證只有一個實例被建立。多執行緒環境下可能產生競爭條件（Race Condition）導致建立多個實例。
*   **解決方案**：將建構子設為 private，並提供一個 static 方法 `getInstance()`。
    *   **多執行緒處理**：
        1.  `synchronized` 方法（效能較差）。
        2.  Eager Creation（急切建立，直接 `new`）。
        3.  Double-checked locking（雙重檢查鎖定，效能較佳）。
*   **意圖**：保證一個類別只有一個實例，並提供一個存取它的全域存取點。

### 4.3 Factory Method Pattern (工廠方法模式)
*   **應用場景**：披薩店。不同分店（NY Style, Chicago Style）製作不同風味的披薩。
*   **問題**：若直接在 `PizzaStore` 中使用 `new` 關鍵字實例化具體披薩，程式碼會依賴於具體類別，難以擴充。
*   **解決方案**：定義一個抽象方法 `createPizza()`。讓子類別（如 `NYPizzaStore`）去實作這個方法來決定要實例化哪種具體的 Pizza 物件。
*   **意圖**：定義一個用於建立物件的介面，讓子類別決定實例化哪一個類別。Factory Method 使一個類別的實例化延遲到其子類別。

### 4.4 Abstract Factory Pattern (抽象工廠模式)
*   **應用場景**：跨平台 GUI 應用程式。需要產生一系列風格一致的元件（視窗、捲軸、按鈕），如 Motif 風格或 PM 風格。
*   **問題**：若分別建立各種風格的元件，容易造成混用或大量的條件判斷程式碼。
*   **解決方案**：定義 `AbstractFactory` 介面（包含 `createWindow`, `createButton` 等方法）。具體的工廠（`MotifWidgetFactory`, `PMWidgetFactory`）負責建立一整族相關的產品。客戶端透過抽象工廠介面建立產品，無需知道具體類別。
*   **意圖**：提供一個介面，用於建立相關或相依物件的家族，而無需指定它們具體的類別。
*   **比較**：**Factory Method** 針對單一產品；**Abstract Factory** 針對產品家族。

---

## 5. 總結
本報告涵蓋了補充講義與主要講義中提及的所有設計模式。透過**封裝變動**、**抽象化**與**介面導向程式設計**，這些模式解決了軟體開發中常見的耦合過高、難以擴充與維護的問題。

*   **行為型模式**關注物件之間的責任分配與演算法封裝（如 Strategy, Observer, Command）。
*   **結構型模式**關注如何組合類別與物件以形成更大的結構（如 Composite, Decorator, Adapter）。
*   **創建型模式**關注物件的建立過程，將實例化邏輯解耦（如 Factory Method, Singleton, Builder）。